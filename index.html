<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fisherman Cashout â€“ 8-bit Edition</title>
<style>
  :root{
    --bg:#0b0f1a;
    --panel:#0f1423;
    --panel-2:#0b1120;
    --accent:#3df5a3;
    --accent-2:#35c7ff;
    --success:#5CFF7D;
    --warn:#ffd94a;
    --danger:#ff6b7a;
    --text:#eaf4ff;
    --muted:#a9bed5;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background: radial-gradient(1100px 600px at 70% -10%, #1a2950 0%, var(--bg) 55%);
    color:var(--text);
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  }
  .pixel { image-rendering: pixelated; image-rendering: crisp-edges; }
  .wrap{
    max-width:1180px; margin:20px auto 64px; padding:0 16px;
    display:grid; grid-template-columns: 1.3fr 1fr; gap:18px;
  }
  header{
    grid-column:1/-1;
    display:flex; align-items:center; justify-content:space-between;
    padding:14px 16px;
    background:linear-gradient(180deg,#0f1830,#0a1022);
    border:2px solid #1e2b4d; border-radius:12px;
    box-shadow: 0 0 0 4px rgba(14,25,45,.6) inset, 0 8px 28px rgba(0,0,0,.35);
  }
  header .title{font-weight:900; letter-spacing:0.5px; font-size:18px}
  header .wallet{display:flex; gap:12px; align-items:center}
  .pill{
    background:linear-gradient(180deg,#0e1630,#0a1124);
    border:2px solid #25345e; padding:8px 12px; border-radius:10px; color:var(--muted); font-size:14px;
    box-shadow:0 2px 0 #0a0f1d, 0 0 0 4px rgba(11,17,32,.5) inset;
  }
  .pill strong{color:#fff}
  .card{background:linear-gradient(180deg,#0e152b,#0a1122); border:2px solid #26345b; border-radius:12px; padding:14px; box-shadow:0 8px 24px rgba(0,0,0,.35)}
  .card h3{margin:0 0 10px 0; font-size:15px; letter-spacing:.3px}
  .btn{
    border:0; padding:10px 14px; cursor:pointer; font-weight:900; letter-spacing:0.4px;
    background:var(--accent); color:#041a0f;
    box-shadow:0 0 0 2px #102a1f inset,0 0 0 4px rgba(0,0,0,.25) inset,0 3px 0 #062814,0 6px 12px rgba(0,0,0,.3);
    border-radius:6px; transition: transform .06s ease, filter .2s ease, opacity .2s ease;
  }
  .btn:hover{ filter:brightness(1.1) }
  .btn:active{ transform:translateY(2px) }
  .btn.secondary{ background:var(--accent-2); color:#04121c; box-shadow:0 0 0 2px #0e2a3a inset,0 0 0 4px rgba(0,0,0,.25) inset,0 3px 0 #062030,0 6px 12px rgba(0,0,0,.3)}
  .btn.warn{ background:var(--warn); color:#2b1a00; box-shadow:0 0 0 2px #6e5300 inset,0 0 0 4px rgba(0,0,0,.25) inset,0 3px 0 #5c4600,0 6px 12px rgba(0,0,0,.3)}
  .btn.success{ background:var(--success); color:#05220d; box-shadow:0 0 0 2px #0d4a1c inset,0 0 0 4px rgba(0,0,0,.25) inset,0 3px 0 #0a3b16,0 6px 12px rgba(0,0,0,.3)}
  .btn.danger{ background:var(--danger); color:#2b0004; box-shadow:0 0 0 2px #5c0011 inset,0 0 0 4px rgba(0,0,0,.25) inset,0 3px 0 #43000d,0 6px 12px rgba(0,0,0,.3)}
  .btn:disabled{opacity:.55; cursor:not-allowed;}
  input[type="number"]{
    background:#0c1222; color:#fff; border:2px solid #27355e; border-radius:8px; padding:10px 12px; width:140px; font-size:15px;
    box-shadow:0 2px 0 #0b1020, 0 0 0 4px rgba(11,17,32,.45) inset;
  }
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .tag{
    background:#0b1222; border:2px solid #26365c; padding:8px 10px; border-radius:8px; font-size:13px; color:#c7d7f0;
    box-shadow:0 2px 0 #0b1020, 0 0 0 4px rgba(11,17,32,.5) inset;
  }
  .tag strong{color:#fff}
  .history{ max-height:280px; overflow:auto; border-radius:10px; background:#0a1121; border:2px solid #26365c; padding:8px; }
  .history .row{ justify-content:space-between; border-bottom:1px dashed #2d4672; padding:6px 2px;}
  .history .row:last-child{border-bottom:0}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
  .game{
    position:relative; overflow:hidden; aspect-ratio: 16/9; border-radius:12px;
    border:2px solid #24345d; background:#0b0f1a;
    box-shadow: 0 0 0 6px rgba(18,26,47,.55) inset, 0 20px 50px rgba(0,0,0,.5);
  }
  canvas{ width:100%; height:100%; display:block; }
  .hud{ position:absolute; top:10px; right:10px; display:flex; gap:10px; flex-wrap:wrap; }
  .big{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    font-size:52px; font-weight:900; letter-spacing:1px; text-shadow:0 8px 24px rgba(0,0,0,.7);
    opacity:0; transition: opacity .2s ease, transform .2s ease;
    pointer-events:none;
  }
  .big.show{ opacity:1; transform:translate(-50%,-52%) }
  .big.win{ color:var(--success) }
  .big.break{ color:var(--danger) }
  .hint{font-size:12px; color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">ðŸŽ£ Fisherman Cashout <span>8-bit</span></div>
      <div class="wallet">
        <div class="pill">Balance: <strong id="wallet">$1,000.00</strong></div>
        <div class="pill">Current Bet: <strong id="currentBet">$0.00</strong></div>
      </div>
    </header>

    <div class="card game">
      <canvas id="gameCanvas" class="pixel" width="320" height="180" aria-label="Fishing scene"></canvas>
      <div class="hud">
        <div class="tag">Attempts: <strong id="attempts">0</strong></div>
        <div class="tag">Break %: <strong id="breakChance">0%</strong></div>
        <div class="tag">Total X: <strong id="totalX">0.00Ã—</strong></div>
        <div class="tag">Potential: <strong id="potentialWin">$0.00</strong></div>
      </div>
      <div class="big" id="big"></div>
    </div>

    <div class="card">
      <h3>Bet & Round</h3>
      <div class="row" style="margin-bottom:8px">
        <input id="betInput" type="number" min="1" step="1" placeholder="Bet amount" />
        <button id="placeBetBtn" class="btn">Place Bet</button>
        <button id="cancelBetBtn" class="btn secondary" disabled>Cancel</button>
      </div>
      <div class="row" style="margin-bottom:8px">
        <button id="tryBtn" class="btn warn" disabled>ðŸŽ¯ Try</button>
        <button id="cashoutBtn" class="btn success" disabled>ðŸ’° Cash Out</button>
        <button id="forfeitBtn" class="btn danger" disabled>â›” Forfeit</button>
      </div>
      <div class="hint">After your first successful try, you can Cash Out. Each try adds a random X but raises break chance.</div>
    </div>

    <div class="card">
      <h3>Config</h3>
      <div class="row" style="margin-bottom:10px">
        <label class="pill">Min X:&nbsp;<input id="minX" type="number" step="0.01" value="1.10" style="width:90px"></label>
        <label class="pill">Max X:&nbsp;<input id="maxX" type="number" step="0.01" value="1.80" style="width:90px"></label>
        <label class="pill">Base Break %:&nbsp;<input id="baseBreak" type="number" step="0.01" value="12" style="width:80px"></label>
        <label class="pill">+% per try:&nbsp;<input id="stepBreak" type="number" step="0.01" value="10" style="width:80px"></label>
        <label class="pill">Cap %:&nbsp;<input id="capBreak" type="number" step="0.01" value="95" style="width:80px"></label>
      </div>
    </div>

    <div class="card">
      <h3>Round History</h3>
      <div id="history" class="history mono"></div>
    </div>
  </div>

<script>
/* ================= CORE GAME STATE ================= */
const state = {
  wallet: 1000,
  inRound: false,
  bet: 0,
  attempts: 0,
  totalX: 0,
  broke: false,
  minX: 1.10,
  maxX: 1.80,
  baseBreak: 12,
  stepBreak: 10,
  capBreak: 95
};
const $ = sel => document.querySelector(sel);
const walletEl = $('#wallet'), currentBetEl = $('#currentBet'), attemptsEl = $('#attempts'), totalXEl = $('#totalX'), breakChanceEl = $('#breakChance'), potentialWinEl = $('#potentialWin');
const betInput = $('#betInput'); const placeBetBtn = $('#placeBetBtn'); const cancelBetBtn = $('#cancelBetBtn'); const tryBtn = $('#tryBtn'); const cashoutBtn = $('#cashoutBtn'); const forfeitBtn = $('#forfeitBtn');
const minXInp = $('#minX'), maxXInp = $('#maxX'), baseBreakInp = $('#baseBreak'), stepBreakInp = $('#stepBreak'), capBreakInp = $('#capBreak');
const bigEl = $('#big'); const historyEl = $('#history');

function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
function fmtMoney(n){ return '$' + n.toFixed(2); }
function randFloat(min, max){ return Math.random() * (max - min) + min; }
function roll(percent){ return Math.random() * 100 < percent; }
function currentBreakChance(){ return clamp(state.baseBreak + state.stepBreak * state.attempts, 0, state.capBreak); }

[minXInp, maxXInp, baseBreakInp, stepBreakInp, capBreakInp].forEach(inp=>{
  inp.addEventListener('change', ()=>{
    state.minX = parseFloat(minXInp.value)||1.10;
    state.maxX = parseFloat(maxXInp.value)||1.80;
    if(state.maxX < state.minX){ state.maxX = state.minX; maxXInp.value=state.maxX.toFixed(2); }
    state.baseBreak = parseFloat(baseBreakInp.value)||12;
    state.stepBreak = parseFloat(stepBreakInp.value)||10;
    state.capBreak  = parseFloat(capBreakInp.value)||95;
    renderHUD();
  });
});

function renderHUD(){
  walletEl.textContent = fmtMoney(state.wallet);
  currentBetEl.textContent = fmtMoney(state.bet);
  attemptsEl.textContent = state.attempts;
  totalXEl.textContent = state.totalX.toFixed(2) + 'Ã—';
  const br = currentBreakChance();
  breakChanceEl.textContent = state.inRound ? br.toFixed(0)+'%' : '0%';
  const potential = state.inRound ? state.bet * state.totalX : 0;
  potentialWinEl.textContent = fmtMoney(potential);
  tryBtn.disabled = !(state.inRound) || state.broke;
  cashoutBtn.disabled = !(state.inRound && state.attempts>=1 && !state.broke);
  cancelBetBtn.disabled = !(state.inRound && state.attempts===0 && !state.broke);
  forfeitBtn.disabled = !(state.inRound);
  betInput.disabled = state.inRound;
  placeBetBtn.disabled = state.inRound;
}
function pushHistory(entry){
  const row=document.createElement('div'); row.className='row';
  row.innerHTML = `<div>${entry.left}</div><div>${entry.right}</div>`;
  historyEl.prepend(row);
}
function showBig(text, type){
  bigEl.textContent = text; bigEl.className='big show '+(type||'');
  setTimeout(()=> bigEl.classList.remove('show'), 1100);
}
function startRound(bet){
  state.inRound = true; state.bet = bet; state.attempts = 0; state.totalX=0; state.broke=false;
  pushHistory({left:"New round", right:`Bet ${fmtMoney(bet)}`});
  renderHUD();
}
function cancelRound(){ pushHistory({left:"Bet canceled", right:`Refund ${fmtMoney(state.bet)}`}); state.inRound=false; state.wallet += state.bet; state.bet=0; renderHUD(); }
function endRoundLose(){ pushHistory({left:"Line broke!", right:`Lost ${fmtMoney(state.bet)}`}); showBig('LINE BROKE!','break'); state.inRound=false; state.bet=0; renderHUD(); }
function endRoundWin(){ const win=+(state.bet*state.totalX).toFixed(2); state.wallet+=win; pushHistory({left:`CASHED @ ${state.totalX.toFixed(2)}Ã—`, right:`Won ${fmtMoney(win)}`}); showBig('CASHED OUT!','win'); state.inRound=false; state.bet=0; renderHUD(); }
function doTry(){
  if(!state.inRound || state.broke) return;
  const br=currentBreakChance();
  const broke = roll(br);
  scene.tug(); // visual feedback
  if(broke){ state.broke=true; endRoundLose(); return; }
  const x=randFloat(state.minX,state.maxX);
  state.attempts += 1;
  state.totalX = +(state.totalX + x).toFixed(2);
  pushHistory({left:`Try #${state.attempts}`, right:`+${x.toFixed(2)}Ã— (Total ${state.totalX.toFixed(2)}Ã—)`});
  showBig(`+${x.toFixed(2)}Ã—`);
  renderHUD();
}
placeBetBtn.addEventListener('click', ()=>{
  const amt = Math.floor(Number(betInput.value || '0'));
  if(!Number.isFinite(amt) || amt<=0){ alert('Enter a valid bet amount.'); return; }
  if(amt>state.wallet){ alert('Insufficient balance.'); return; }
  state.wallet -= amt; startRound(amt);
});
cancelBetBtn.addEventListener('click', ()=>{ if(state.inRound && state.attempts===0 && !state.broke) cancelRound(); });
forfeitBtn.addEventListener('click', ()=>{ if(!state.inRound) return; pushHistory({left:"Forfeit", right:`Lost ${fmtMoney(state.bet)}`}); state.inRound=false; state.bet=0; renderHUD(); });
tryBtn.addEventListener('click', doTry);
cashoutBtn.addEventListener('click', ()=>{ if(state.inRound && state.attempts>=1 && !state.broke) endRoundWin(); });
document.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='t') doTry(); else if(e.key.toLowerCase()==='c'){ if(state.inRound && state.attempts>=1 && !state.broke) endRoundWin(); } });
renderHUD();

/* ================= PIXEL SCENE (Canvas) ================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha:false });
function r(x,y,w,h,c){ ctx.fillStyle=c; ctx.fillRect(x|0,y|0,w|0,h|0); }
const P = {
  sky1:'#1a2344', sky2:'#0f1734',
  sun:'#f6e27a',
  water1:'#10305a', water2:'#143a6d', foam:'#8edaff',
  shore1:'#18253f',
  skin:'#f6d7b0', coat:'#2a3b6b', rod:'#b28b58', line:'#e1f1ff',
  bobberRed:'#ff6b7a', bobberWhite:'#ffffff',
  fish:'#87ffc0', fishDark:'#2a8a6a', sparkle:'#ffffff'
};
const scene = {
  t:0, wobble:0, splash:0, sparkles:[],
  tug(){ this.wobble=8; this.splash=1; this.spawnSparkles(); },
  spawnSparkles(){
    const bx = 210, by = 105;
    for(let i=0;i<6;i++){
      this.sparkles.push({x:bx+Math.random()*10-5, y:by+Math.random()*8-4, life:1, vx:(Math.random()-.5)*.6, vy:-Math.random()*0.6});
    }
  },
  step(dt){
    this.t += dt;
    if(this.wobble>0) this.wobble = Math.max(0, this.wobble - dt*12);
    if(this.splash>0) this.splash = Math.max(0, this.splash - dt*3);
    this.sparkles.forEach(s=>{ s.x+=s.vx; s.y+=s.vy; s.vy+=0.02; s.life-=dt*1.5; });
    this.sparkles = this.sparkles.filter(s=>s.life>0);
  },
  draw(){
    const t=this.t;
    for(let y=0;y<90;y++){ const mix=y/90; const c=lerpColor(P.sky1,P.sky2,mix); r(0,y,320,1,c); }
    r(270,18,12,12,P.sun); r(270,30,12,2,P.sun);
    r(0,78,320,12,P.shore1);
    for(let y=90;y<180;y++){ const mix=(y-90)/90; const c=lerpColor(P.water1,P.water2,mix); r(0,y,320,1,c); }
    ctx.globalAlpha = .25; for(let i=0;i<12;i++){ const yy = 100 + i*6 + Math.sin(t*1.2 + i)*1.5; r(0,yy,320,1,P.foam); } ctx.globalAlpha = 1;
    r(0,88,320,2,P.foam);
    const wob = Math.sin(t*8)*(this.wobble>0? this.wobble*0.4 : 1);
    r(34,70,16,18,P.coat); r(38,62,8,8,P.skin); r(48,76,4,6,P.coat);
    ctx.fillStyle=P.rod; ctx.fillRect(52,74,1,30); ctx.fillRect(53,74,1,30);
    ctx.fillStyle=P.line; const lineX = 210 + Math.sin(t*2)*2 + wob*0.5;
    for(let y=76;y<105;y+=2){ ctx.fillRect(53, y, 1, 1); }
    drawLinePixel(53,104,lineX,114,P.line);
    const by = 105 + Math.sin(t*2.2)*2 + wob*0.8;
    r(lineX-2,by-2,4,4,P.bobberWhite); r(lineX-2,by-2,4,2,P.bobberRed);
    const fx = 40 + ((t*25)%360); const fy = 130 + Math.sin(t*2)*4;
    r(fx,fy,6,3,P.fish); r(fx+1,fy+1,4,1,P.fishDark);
    if(this.splash>0){ r(lineX-4, by-6, 8, 1, P.foam); r(lineX-6, by-4, 12, 1, P.foam); }
    this.sparkles.forEach(s=>{ ctx.globalAlpha = s.life; r(s.x, s.y, 1, 1, P.sparkle); ctx.globalAlpha = 1; });
  }
};
function drawLinePixel(x0,y0,x1,y1,color){
  ctx.fillStyle=color;
  const dx=Math.abs(x1-x0), sx=x0<x1?1:-1;
  const dy=-Math.abs(y1-y0), sy=y0<y1?1:-1;
  let err=dx+dy, e2;
  while(true){
    ctx.fillRect(x0|0,y0|0,1,1);
    if(x0===x1 && y0===y1) break;
    e2=2*err;
    if(e2>=dy){ err+=dy; x0+=sx; }
    if(e2<=dx){ err+=dx; y0+=sy; }
  }
}
function lerpColor(a,b,t){
  const ah=parseInt(a.replace('#',''),16), ar=(ah>>16)&255, ag=(ah>>8)&255, ab=ah&255;
  const bh=parseInt(b.replace('#',''),16), br=(bh>>16)&255, bg=(bh>>8)&255, bb=bh&255;
  const rr = (ar + (br-ar)*t)|0, rg=(ag + (bg-ag)*t)|0, rb=(ab + (bb-ab)*t)|0;
  return '#' + ((1<<24) + (rr<<16) + (rg<<8) + rb).toString(16).slice(1);
}
let last=0;
function loop(ts){
  const dt = (ts-last)/1000 || 0.016; last=ts;
  scene.step(dt);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  scene.draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
